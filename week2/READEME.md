自己主要动手测试了并行GC和CMS GC，并通过打印jvm的GC日志对比了两种GC的差别，以下是结合个人经验和课上内容以及参考一些其他文档的总结内容

1.串行GC

年轻代使用标记-复制算法，老年代使用标记-清除-整理算法，串行GC顾名思义单线程执行，同时阻塞业务，即发生STW，由于不能充分利用多核CPU，因此一般情况下性能相对其他GC算法会稍显下降

2.并行GC

算法基本与串行GC类似，清理同样会触发STW，最大的差别在于可以通过多线程利用多核CPU的优势，减少对业务的影响，是java8的默认配置

3.CMS GC

CMS(Mostly Concurrent Mark and Sweep)算法在年轻代仍采用标记-复制算法，同样触发STW，与前两种GC的区别主要在对老年代的处理上，
CMS GC对老年代使用标记-清除算法，不进行整理，而是用空闲列表（free-lists）来管理内存空间的回收，另外不触发STW，是与应用线程争抢CPU来并发执行，默认情况下线程数为CPU核数1/4

使用下来感觉与并行GC最大的区别在于不会触发full GC，即是对老年代的处理方式不同，并且同样的测试流程下来CMS GC 所占用的时间更短（主要是没有full GC），因此CMS GC更适合用在对业务有需要低时延要求的场景

不过后来发现CMS GC好像在2015年就被官方废弃掉了，所以如果使用更高的Java版本还是用G1 GC吧

4.G1 GC

Java11 默认的GC就是G1 GC，G1（Garbage-First）算法与前面的算法有很大的不同，首先对内存的划分就很不一样，G1算法不再把内存直接分成年轻代和老年代，而是划分为多个小块，这些小块的类型也不是固定，既有可能是Eden，也有可能是Survivor或Old区

G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集。这也是G1名称的由来

